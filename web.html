<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å±€åŸŸç½‘æ–‡å­—</title>
    <style>
        /* æç®€æ ·å¼ï¼Œæ— å¤šä½™è£…é¥° */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { padding: 20px; font-family: sans-serif; background: #f5f5f5; }
        #deviceList { margin-bottom: 15px; padding: 10px; background: #fff; border-radius: 4px; }
        #chatBox { height: 70vh; overflow-y: auto; padding: 10px; background: #fff; border-radius: 4px; margin-bottom: 15px; }
        .msg { margin: 8px 0; padding: 6px; border-radius: 3px; }
        .self { background: #e3f2fd; color: #0d47a1; text-align: right; }
        .peer { background: #f1f8e9; color: #2e7d32; text-align: left; }
        .system { color: #9e9e9e; font-size: 12px; text-align: center; }
        #inputArea { display: flex; gap: 10px; }
        #msgInput { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
        #sendBtn { padding: 0 20px; border: none; background: #2196f3; color: #fff; border-radius: 4px; cursor: pointer; }
        /* éšè—äº¤äº’æ§ä»¶ï¼ˆæŒ‰éœ€å¯ç”¨ï¼Œå®ç°çº¯åªè¯»ï¼‰ */
        /* #inputArea, #deviceList { display: none; } */
    </style>
</head>
<body>
    <div id="deviceList">è®¾å¤‡å‘ç°ä¸­...</div>
    <div id="chatBox"></div>
    <div id="inputArea">
        <input type="text" id="msgInput" placeholder="è¾“å…¥æ¶ˆæ¯å‘é€">
        <button id="sendBtn">å‘é€</button>
    </div>

    <script>
        // DOM å…ƒç´ 
        const deviceList = document.getElementById('deviceList');
        const chatBox = document.getElementById('chatBox');
        const msgInput = document.getElementById('msgInput');
        const sendBtn = document.getElementById('sendBtn');

        // æ ¸å¿ƒé…ç½®
        const CHANNEL_NAME = 'lan-chat-broadcast';
        const PEER_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        let peerConnection = null;
        let dataChannel = null;
        let localPeerId = `peer-${Math.random().toString(36).slice(2, 8)}`; // éšæœºè®¾å¤‡ID
        let remotePeerId = null;

        // 1. å¹¿æ’­é€šé“ï¼šå®ç°åŒç½‘æ®µè®¾å¤‡è‡ªåŠ¨å‘ç°
        const broadcastChannel = new BroadcastChannel(CHANNEL_NAME);
        broadcastChannel.onmessage = (e) => {
            const { type, from, data } = e.data;
            if (from === localPeerId) return; // å¿½ç•¥è‡ªå·±çš„æ¶ˆæ¯

            switch (type) {
                case 'DISCOVER':
                    // å“åº”è®¾å¤‡å‘ç°
                    broadcastChannel.postMessage({
                        type: 'DISCOVER_RESP',
                        from: localPeerId,
                        data: 'online'
                    });
                    updateDeviceList(`å‘ç°è®¾å¤‡: ${from}`);
                    remotePeerId = from;
                    break;
                case 'DISCOVER_RESP':
                    updateDeviceList(`è®¾å¤‡åœ¨çº¿: ${from}`);
                    remotePeerId = from;
                    break;
                case 'SDP_OFFER':
                    handleOffer(data);
                    break;
                case 'SDP_ANSWER':
                    handleAnswer(data);
                    break;
                case 'ICE_CANDIDATE':
                    peerConnection?.addIceCandidate(new RTCIceCandidate(data));
                    break;
            }
        };

        // 2. åˆå§‹åŒ–ï¼šå‘é€è®¾å¤‡å‘ç°å¹¿æ’­
        function init() {
            updateDeviceList('æ­£åœ¨æœç´¢å±€åŸŸç½‘è®¾å¤‡...');
            broadcastChannel.postMessage({
                type: 'DISCOVER',
                from: localPeerId,
                data: ''
            });
        }

        // 3. WebRTC è¿æ¥å¤„ç†
        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(PEER_CONFIG);
            
            // ç›‘å¬æ•°æ®é€šé“
            peerConnection.ondatachannel = (e) => {
                dataChannel = e.channel;
                setupDataChannel();
            };

            // åˆ›å»ºæ•°æ®é€šé“ï¼ˆå‘èµ·æ–¹ï¼‰
            dataChannel = peerConnection.createDataChannel('chat-channel');
            setupDataChannel();

            // ICE å€™é€‰å¤„ç†
            peerConnection.onicecandidate = (e) => {
                if (e.candidate) {
                    broadcastChannel.postMessage({
                        type: 'ICE_CANDIDATE',
                        from: localPeerId,
                        data: e.candidate.toJSON()
                    });
                }
            };

            peerConnection.onconnectionstatechange = () => {
                switch (peerConnection.connectionState) {
                    case 'connected':
                        appendMsg('âœ… P2P è¿æ¥æˆåŠŸ', 'system');
                        break;
                    case 'disconnected':
                        appendMsg('âŒ è¿æ¥å·²æ–­å¼€', 'system');
                        break;
                }
            };
        }

        // å¤„ç† SDP Offer
        async function handleOffer(offer) {
            if (!peerConnection) createPeerConnection();
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            broadcastChannel.postMessage({
                type: 'SDP_ANSWER',
                from: localPeerId,
                data: answer.toJSON()
            });
        }

        // å¤„ç† SDP Answer
        async function handleAnswer(answer) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }

        // å‘èµ·è¿æ¥ï¼ˆåˆ›å»º Offerï¼‰
        async function startConnection() {
            if (!remotePeerId) {
                appendMsg('âš ï¸ æœªå‘ç°å±€åŸŸç½‘è®¾å¤‡', 'system');
                return;
            }
            if (!peerConnection) createPeerConnection();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            broadcastChannel.postMessage({
                type: 'SDP_OFFER',
                from: localPeerId,
                data: offer.toJSON()
            });
        }

        // 4. æ•°æ®é€šé“é…ç½®
        function setupDataChannel() {
            dataChannel.onopen = () => appendMsg('ğŸ“¡ æ¶ˆæ¯é€šé“å·²å°±ç»ª', 'system');
            dataChannel.onmessage = (e) => appendMsg(e.data, 'peer');
            dataChannel.onclose = () => appendMsg('ğŸ“¡ æ¶ˆæ¯é€šé“å·²å…³é—­', 'system');
        }

        // 5. è¾…åŠ©å‡½æ•°
        function updateDeviceList(text) {
            deviceList.textContent = text;
        }

        function appendMsg(text, type) {
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            div.textContent = text;
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function sendMsg() {
            const text = msgInput.value.trim();
            if (!text || !dataChannel || dataChannel.readyState !== 'open') return;
            dataChannel.send(text);
            appendMsg(text, 'self');
            msgInput.value = '';
        }

        // äº‹ä»¶ç»‘å®š
        sendBtn.addEventListener('click', sendMsg);
        msgInput.addEventListener('keydown', (e) => e.key === 'Enter' && sendMsg());
        // ç‚¹å‡»è®¾å¤‡åˆ—è¡¨æ‰‹åŠ¨å‘èµ·è¿æ¥
        deviceList.addEventListener('click', startConnection);

        // å¯åŠ¨ç¨‹åº
        init();
    </script>
</body>
</html>